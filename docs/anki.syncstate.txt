What does "sync state" mean in the WireGuard handshake?|Both parties reach identical cryptographic values (hash and chainingKey) by mirroring each other's operations. This proves both ran the same protocol correctly and can derive the same transport keys
Why is state synchronization critical in the handshake?|If the cryptographic states don't match (hash or chainingKey are different), the handshake fails. Without synchronized state, parties cannot derive the same transport keys and cannot communicate
How does the responder "sync" with the initiator's state?|The responder performs the same cryptographic operations as the initiator but from their perspective:<br>1. Same hash operations with same data<br>2. Same KDF operations with same inputs<br>3. Same DH operations (commutative: A×B = B×A)<br><br>Result: identical hash and chainingKey values
What does "reverse" mean in "implements the reverse of CreateMessageInitiation"?|Mirror the operations from the other perspective, NOT undo them.<br><br>Example: Initiator encrypts with DH(my_ephemeral, their_static), Responder decrypts with DH(my_static, their_ephemeral). Different perspectives, same shared secret (DH is commutative)
After both parties sync state, what can they do?|Both have identical chainingKey containing all handshake secrets. They can now derive the same transport keys for encrypting data packets
Why does WireGuard use two separate keys for transport instead of one?|<b>Security reasons</b>:<br>1. Prevents nonce reuse - each direction has independent nonce space<br>2. Separate cryptographic contexts - if both used same key, nonce coordination would be complex and error-prone<br>3. Protocol clarity - clear directionality (sendKey vs recvKey)
What would happen if both peers used the same key for sending and receiving?|<b>Nonce collision catastrophe</b>:<br>Alice: AEAD(key, nonce=5, data_A)<br>Bob: AEAD(key, nonce=5, data_B)<br><br>Both using same (key, nonce) pair = reused nonce = encryption broken, can leak keystream
How does WireGuard derive two transport keys from one chainingKey?|<code>sendKey, recvKey = kdf2(chainingKey, nil)</code><br><br>KDF2 uses domain separation:<br>key1 = HMAC(extracted, 0x1)<br>key2 = HMAC(extracted, key1 || 0x2)<br><br>Different counters ensure cryptographic independence
If both parties derive the same two keys, how do they avoid using the same key for sending?|<b>Role-based assignment (swapped)</b>:<br><br>Initiator: sendKey=key1, recvKey=key2<br>Responder: sendKey=key2, recvKey=key1<br><br>Result: Initiator sends with key1, Responder receives with key1 ✅
What is the domain separation in kdf2 and why is it important?|Using different counters (0x1, 0x2) in the HMAC expansion ensures the two output keys are cryptographically independent. Even if key1 leaks, it doesn't help compute key2
After deriveTransportKeys, what does the initiator do with the keys?|<code>sendKey, recvKey = deriveTransportKeys(chainingKey)<br>establishSession(sendKey, recvKey, ...)</code><br><br>Uses sendKey for encrypting outgoing packets, recvKey for decrypting incoming packets
After deriveTransportKeys, what does the responder do with the keys?|<code>sendKey, recvKey = deriveTransportKeys(chainingKey)<br>establishSession(recvKey, sendKey, ...)</code><br><br><b>Note the swap!</b> Uses recvKey for sending, sendKey for receiving (opposite of initiator)
What proves that both parties have the private keys they claim to have?|The DH operations in the handshake:<br>1. DH(ephemeral_private, peer_static_public) - proves I have ephemeral private<br>2. DH(static_private, peer_static_public) - proves I have static private<br><br>AEAD decryption succeeds only if both parties computed same DH shared secrets
What happens if the responder's hash value doesn't match the initiator's after processing message 1?|When the responder tries to create the response, the AEAD encryption will use the wrong hash as additional data. The initiator will fail to decrypt the response (auth tag mismatch) and abort the handshake
Why does AEAD use the hash as additional data in handshake messages?|To bind the encryption to the exact state of the handshake. If someone tampers with earlier messages (changing the hash), AEAD decryption fails. This prevents message substitution attacks
Show the key flow for a complete handshake|<b>Both derive</b>: key1, key2 = kdf2(chainingKey, nil)<br><br><b>Initiator</b>:<br>Send with key1, nonce 0,1,2...<br>Recv with key2, expect nonce 0,1,2...<br><br><b>Responder</b>:<br>Send with key2, nonce 0,1,2...<br>Recv with key1, expect nonce 0,1,2...<br><br>No nonce collision possible!
What does "cryptographically valid" mean in the context of sync state?|Both parties arrive at the same hash and chainingKey values through proper execution of the protocol. The values are cryptographically linked to:<br>1. Both ephemeral keys<br>2. All DH shared secrets<br>3. Pre-shared key (if any)<br>4. All message data<br><br>Any deviation = different values = handshake fails
How does the handshake prove mutual authentication?|Both parties perform DH operations that require their private keys:<br><br>DH(initiator_static_private, responder_static_public)<br>DH(responder_static_private, initiator_static_public)<br><br>If either lacks the correct private key, they compute wrong shared secret → wrong encryption keys → AEAD fails
What is the significance of both parties reaching the same chainingKey value?|The chainingKey is the cumulative result of all cryptographic operations (DH operations, key mixing). If both have the same value, it proves:<br>1. They performed same protocol steps<br>2. Used correct private keys<br>3. Can derive identical transport keys<br>4. Handshake succeeded
Why can't an eavesdropper sync state with either party?|The eavesdropper sees public keys and ciphertexts but cannot compute the DH shared secrets (needs private keys). Without DH results, cannot derive correct chainingKey. Without correct chainingKey, cannot derive encryption keys or decrypt messages
If initiator and responder use separate keys, do they need separate nonce counters?|Yes! Each party maintains its own nonce counter starting from 0:<br><br>Initiator: sendNonce (for encrypting with sendKey)<br>Responder: sendNonce (for encrypting with its sendKey)<br><br>These are independent - both can use nonce=5 simultaneously because they use different keys
