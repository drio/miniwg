What is the fundamental property of a cryptographic hash function?|Deterministic (same input always produces same output), one-way (cannot reverse), collision-resistant (hard to find two inputs with same hash), and exhibits avalanche effect (small input change produces completely different output)
What hash function does WireGuard use and what is its output size?|BLAKE2s, which always produces 32-byte output regardless of input size
What is the difference between a MAC and encryption?|MAC provides authentication and integrity (proves message came from someone with the key and detects tampering) but does NOT encrypt the message - the message remains readable
What is HMAC and why is it used instead of simple MAC?|HMAC (Hash-based MAC) is a more secure MAC construction using a hash function with the formula: \( \text{HMAC}(K, m) = H((K \oplus \text{opad}) \| H((K \oplus \text{ipad}) \| m)) \). It has mathematical proofs of security when the underlying hash function is secure
What is the magic property of Diffie-Hellman key exchange?|Two parties can each compute the same shared secret using their own private key and the other party's public key: \( \text{sharedSecret} = \text{alicePrivate} \times \text{bobPublic} = \text{bobPrivate} \times \text{alicePublic} \), while an eavesdropper who only sees the public keys cannot compute the shared secret
What elliptic curve does WireGuard use for Diffie-Hellman operations?|Curve25519
What does AEAD stand for and what does it provide?|Authenticated Encryption with Associated Data. It provides three operations in one: (1) Encrypt plaintext to ciphertext, (2) Authenticate ciphertext (detect tampering), (3) Authenticate additional data without encrypting it
What AEAD cipher does WireGuard use?|ChaCha20-Poly1305
In AEAD encryption, what is the purpose of "additional data"?|It binds the encryption to a specific context. The additional data is authenticated (included in the auth tag calculation) but NOT encrypted. If an attacker changes the additional data, decryption will fail. In WireGuard, the hash transcript is used as additional data to ensure ciphertext is only valid in the specific handshake context
What is the critical rule about nonce reuse in AEAD encryption?|NEVER reuse a (key, nonce) pair for encryption. Reusing the same nonce with the same key is catastrophic and can leak the key
Why can WireGuard handshake messages use nonce=0 for AEAD encryption?|Because each encryption key in the handshake is single-use. For example, tempKey1 is used once to encrypt the static key with nonce=0, then never used again. tempKey2 is used once to encrypt the timestamp with nonce=0, then never used again
What is a KDF (Key Derivation Function) and why is it needed?|A KDF derives multiple independent keys from one secret. It's needed because you should never use raw cryptographic material (like DH output) directly as an encryption key. KDF strengthens the input and produces multiple independent keys for different purposes
What is the HKDF pattern and what are its two phases?|HKDF has two phases: <b>Extract</b> (strengthen): \( \text{strongKey} = \text{HMAC}(\text{salt}, \text{inputKeyMaterial}) \), and <b>Expand</b> (stretch): \( \text{output}_i = \text{HMAC}(\text{strongKey}, \text{output}_{i-1} \| i) \) for \( i = 1, 2, 3, \ldots \)
Why does WireGuard have kdf1, kdf2, and kdf3 instead of just one KDF function?|Different steps in the handshake need different numbers of output keys: kdf1 produces 1 output (update chaining key only), kdf2 produces 2 outputs (new chaining key + encryption key), kdf3 produces 3 outputs (new chaining key + tau + encryption key)
What is the purpose of using different counters (0x1, 0x2, 0x3) in KDF expansion?|Domain separation - it makes each output cryptographically independent. If output1 leaks, it doesn't help an attacker compute output2
What is the chaining key in the Noise protocol?|A running accumulator of all cryptographic material in the handshake. It starts with InitialChainKey and gets updated at each step: \( \text{chainingKey}_{\text{new}} = \text{KDF}(\text{chainingKey}_{\text{old}}, \text{newSecret}) \). By the end, it contains cryptographic proof of all DH operations and secrets
What is the hash transcript in the Noise protocol?|A running hash of all messages exchanged in the handshake: \( \text{hash}_{\text{new}} = \text{HASH}(\text{hash}_{\text{old}} \| \text{newData}) \). It records what was sent (public data, ciphertexts) and is used as additional data in AEAD to bind encryption to the conversation context
What is the key difference between the hash transcript and the chaining key?|<b>Hash transcript</b>: Records what was sent (public data, ciphertexts), used for authentication/context binding<br><b>Chaining key</b>: Records secrets shared (DH results), used for key derivation<br><br>Hash includes public data; chaining key only includes secrets
What is forward secrecy?|The property that if long-term (static) keys leak in the future, past sessions remain secure. This is achieved by using ephemeral (temporary) keys that are deleted after the handshake, so even if static keys are compromised later, the ephemeral keys are gone forever
How many DH operations occur in a complete WireGuard handshake?|5 unique DH operations (though implemented as 8 total operations since each party computes some of the same shared secrets)
What are the 5 unique DH operations in the WireGuard Noise_IK handshake?|1. \( \text{ephemeral}_i \times \text{static}_r \) (encrypt initiator static)<br>2. \( \text{static}_i \times \text{static}_r \) (mutual authentication)<br>3. \( \text{ephemeral}_i \times \text{ephemeral}_r \) (forward secrecy)<br>4. \( \text{static}_i \times \text{ephemeral}_r \) (bind responder ephemeral)<br>5. Pre-shared key (optional, not a DH but acts like 5th secret)
Why does the initiator encrypt their static public key in the handshake?|<b>Identity hiding</b> - the initiator's identity is encrypted so an eavesdropper cannot tell who is handshaking with the responder. Only the responder can decrypt it (using the DH shared secret from ephemeral-static)
What is the purpose of the timestamp in the WireGuard handshake initiation message?|<b>Replay protection</b> - each handshake must have an increasing timestamp. The responder rejects any handshake with a timestamp ≤ the last seen from this peer, preventing replay of old handshake messages
What is TAI64N timestamp format?|12 bytes total: first 8 bytes = seconds since 1970 (big-endian), last 4 bytes = nanoseconds within that second (big-endian). The critical property: timestamps must ALWAYS increase
What is MAC1 in WireGuard handshake messages?|MAC1 = \( \text{MAC}(\text{HASH}(\text{"mac1----"} \| \text{peer}_{\text{static}_{\text{public}}}), \text{message}_{\text{bytes}}) \). It proves the sender knows the responder's static public key
What are the security purposes of MAC1?|<b>Access Control</b>: Only someone who knows the responder's public key can create valid MAC1<br><b>Silence Property</b>: Server remains completely silent (no response) to invalid MAC1<br><b>Stealth</b>: Makes WireGuard invisible to port scanners<br><b>Anti-DoS</b>: Fast validation before expensive crypto operations
What is MAC2 in WireGuard handshake messages?|MAC2 = \( \text{MAC}(\text{cookie}, \text{message}_{\text{bytes}}) \) OR zeros if no cookie. It provides advanced DoS protection through a cookie system when the responder is under heavy load
What does an initiator put in the MAC2 field when creating their first handshake message?|16 zero bytes (unless they have a cookie from a previous cookie reply message)
How does the cookie system protect against DoS attacks?|Under load, the responder sends a cookie reply instead of processing the handshake: \( \text{cookie} = \text{MAC}(\text{server}_{\text{secret}}, \text{client}_{\text{IP}}) \). The client must then resend with valid MAC2. This proves IP ownership (prevents spoofing) and allows stateless rate limiting
What are the 4 parts of the WireGuard Noise_IK handshake?|1. CreateMessageInitiation (initiator creates message 1)<br>2. ConsumeMessageInitiation (responder processes message 1)<br>3. CreateMessageResponse (responder creates message 2)<br>4. ConsumeMessageResponse (initiator processes message 2)
What does "IK" mean in Noise_IK?|<b>I</b> = Initiator's static key transmitted (encrypted)<br><b>K</b> = Responder's static key Known beforehand
In CreateMessageInitiation Step 1, what are the initial values for hash and chainingKey?|chainingKey = InitialChainKey = \( \text{HASH}(\text{"Noise\_IKpsk2\_25519\_ChaChaPoly\_BLAKE2s"}) \)<br>hash = InitialHash = \( \text{HASH}(\text{InitialChainKey} \| \text{"WireGuard v1 zx2c4 Jason@zx2c4.com"}) \)
In CreateMessageInitiation Step 2, what is mixed into the hash and why?|The responder's static public key: \( \text{hash} = \text{HASH}(\text{hash} \| \text{peer}_{\text{static}_{\text{public}}} ) \). This starts the transcript by recording "I'm talking to peer X"
In CreateMessageInitiation Step 3, what happens?|Generate ephemeral keypair: 32 random bytes for private key, then \( \text{publicKey} = \text{privateKey} \times \text{Curve25519}_{\text{basepoint}} \). These are temporary keys used only for this handshake to provide forward secrecy
In CreateMessageInitiation Step 4, what is mixed into the hash?|The ephemeral public key: \( \text{hash} = \text{HASH}(\text{hash} \| \text{ephemeral}_{\text{public}} ) \). This adds to the transcript: "Here's my ephemeral public key"
In CreateMessageInitiation Step 5, how is the chaining key updated?|Using kdf1: \( \text{chainingKey}_{\text{new}} = \text{kdf1}(\text{chainingKey}, \text{ephemeral}_{\text{public}}) \). This mixes the ephemeral key into the running accumulator of cryptographic material
In CreateMessageInitiation Step 6, what is the first DH operation and what is it used for?|DH1 = \( \text{DH}(\text{ephemeral}_{\text{private}}, \text{peer}_{\text{static}_{\text{public}}}) \). Then \( \text{chainingKey}, \text{encryptKey1} = \text{kdf2}(\text{chainingKey}, \text{DH1}) \). The encryptKey1 will be used to encrypt the initiator's static public key
In CreateMessageInitiation Step 7, what gets encrypted and how?|The initiator's static public key: \( \text{encryptedStatic} = \text{AEAD}(\text{tempKey1}, \text{nonce}=0, \text{ourStaticPub}, \text{hash}) \). Result is 48 bytes (32 bytes encrypted + 16 byte auth tag). This provides identity hiding
In CreateMessageInitiation Step 9, what is the second DH operation?|DH2 = \( \text{DH}(\text{our}_{\text{static}_{\text{private}}}, \text{peer}_{\text{static}_{\text{public}}}) \). This is the static-static DH that provides mutual authentication. Then \( \text{chainingKey}, \text{encryptKey2} = \text{kdf2}(\text{chainingKey}, \text{DH2}) \)
In CreateMessageInitiation Step 10, what gets encrypted and why?|The TAI64N timestamp: \( \text{encryptedTimestamp} = \text{AEAD}(\text{tempKey2}, \text{nonce}=0, \text{timestamp}, \text{hash}) \). Result is 28 bytes (12 bytes + 16 byte tag). This provides replay protection - responder rejects if timestamp ≤ last seen
What are the contents of the HandshakeInitiation message sent on the wire?|Type (1 byte), Sender index (4 bytes), Ephemeral public key (32 bytes), Encrypted static (48 bytes), Encrypted timestamp (28 bytes), MAC1 (16 bytes), MAC2 (16 bytes). Total: 148 bytes
In ConsumeMessageInitiation, how does the responder validate MAC1?|Calculates expected MAC1 using their own static public key: \( \text{expected} = \text{MAC1}(\text{message}_{\text{bytes}}, \text{our}_{\text{static}_{\text{public}}}) \). If it doesn't match received MAC1, the message is silently dropped
In ConsumeMessageInitiation Step 8, what DH operation does the responder perform?|DH1 = \( \text{DH}(\text{our}_{\text{static}_{\text{private}}}, \text{initiator}_{\text{ephemeral}_{\text{public}}}) \). This computes the same shared secret as the initiator's first DH, but from the other side. Used to derive the key to decrypt the initiator's static key
In ConsumeMessageInitiation Step 9, what does the responder decrypt?|The initiator's static public key: \( \text{decryptedStatic} = \text{AEAD}_{\text{decrypt}}(\text{decryptKey1}, 0, \text{msg.Static}, \text{hash}) \). If AEAD decryption fails, the handshake is rejected. Result is 32 bytes (the initiator's identity)
In ConsumeMessageInitiation Step 11, what is the second DH operation?|DH2 = \( \text{DH}(\text{our}_{\text{static}_{\text{private}}}, \text{initiator}_{\text{static}_{\text{public}}}) \). This computes the same static-static shared secret as the initiator. Derives key to decrypt the timestamp
In ConsumeMessageInitiation Step 12, what gets decrypted and validated?|The timestamp: \( \text{decryptedTimestamp} = \text{AEAD}_{\text{decrypt}}(\text{decryptKey2}, 0, \text{msg.Timestamp}, \text{hash}) \). Then validates \( \text{timestamp} > \text{lastTimestamp} \) to prevent replay attacks
In CreateMessageResponse Step 1, what does the responder generate?|A new ephemeral keypair for the responder. This ephemeral key will be used for the final DH operations to derive transport keys and provide forward secrecy
In CreateMessageResponse Step 4, what is the third DH operation?|DH3 = \( \text{DH}(\text{responder}_{\text{ephemeral}_{\text{private}}}, \text{initiator}_{\text{ephemeral}_{\text{public}}}) \). This is the ephemeral-ephemeral DH that provides forward secrecy. Then mixed into chaining key with kdf1
In CreateMessageResponse Step 5, what is the fourth DH operation?|DH4 = \( \text{DH}(\text{responder}_{\text{ephemeral}_{\text{private}}}, \text{initiator}_{\text{static}_{\text{public}}}) \). This binds the responder's ephemeral key to the initiator's identity. Then mixed into chaining key with kdf1
In CreateMessageResponse Step 6, what gets mixed in with kdf3?|The pre-shared key (PSK): \( \text{chainingKey}, \text{tau}, \text{encryptKey} = \text{kdf3}(\text{chainingKey}, \text{PSK}) \). In miniwg, PSK is all zeros. The tau value gets mixed into the hash for authentication
In CreateMessageResponse Step 7, what gets encrypted?|An empty payload: \( \text{encryptedEmpty} = \text{AEAD}(\text{encryptKey}, 0, \text{[]}, \text{hash}) \). Result is 16 bytes (0 bytes + 16 byte tag). This proves the responder can perform encryption and confirms correct key derivation
What are the contents of the HandshakeResponse message?|Type (1 byte), Sender index (4 bytes), Receiver index (4 bytes), Ephemeral public key (32 bytes), Encrypted empty (16 bytes), MAC1 (16 bytes), MAC2 (16 bytes). Total: 92 bytes
In ConsumeMessageResponse Step 6, what DH operation does the initiator perform?|DH3 = \( \text{DH}(\text{initiator}_{\text{ephemeral}_{\text{private}}}, \text{responder}_{\text{ephemeral}_{\text{public}}}) \). This computes the same ephemeral-ephemeral shared secret as the responder, providing forward secrecy
In ConsumeMessageResponse Step 7, what is the final DH operation?|DH4 = \( \text{DH}(\text{initiator}_{\text{static}_{\text{private}}}, \text{responder}_{\text{ephemeral}_{\text{public}}}) \). This computes the same ephemeral-static shared secret as the responder, completing the authentication pattern
In ConsumeMessageResponse Step 9, what does the initiator decrypt and verify?|The empty payload: \( \text{decryptedEmpty} = \text{AEAD}_{\text{decrypt}}(\text{decryptKey}, 0, \text{response.Empty}, \text{hash}) \). Must be exactly 0 bytes. If decryption fails or payload isn't empty, handshake is rejected
After the handshake completes, how are the final transport keys derived?|From the final chaining key (which now contains all 4 DH results + PSK): \( \text{sendKey}, \text{recvKey} = \text{kdf2}(\text{finalChainingKey}, \text{nil}) \). These two keys are used for all subsequent data packet encryption
Why are the send and receive keys different even though derived from the same chaining key?|Because kdf2 uses domain separation with counters: \( \text{sendKey} = \text{HMAC}(\text{extracted}, 0x1) \) and \( \text{recvKey} = \text{HMAC}(\text{extracted}, \text{sendKey} \| 0x2) \). This makes them cryptographically independent
What is the purpose of anti-replay protection in transport data packets?|Prevents an attacker from capturing legitimate encrypted packets and retransmitting them later (replaying them). Even though the attacker can't decrypt the packets, replaying them could cause unintended effects
How does miniwg implement replay protection for transport data?|Simple counter check: rejects any packet with counter ≤ last received counter. This works for learning but breaks with out-of-order packet delivery
How does WireGuard-Go implement replay protection?|Uses a sliding window bitmap (RFC 6479): maintains a window of 8,128 packets with a bitmap tracking which counters have been seen. Accepts packets within the window that haven't been seen before, rejects duplicates and packets too old
What is the problem with miniwg's simple counter-based replay protection?|It rejects ANY packet with counter ≤ last received, which means legitimate packets that arrive out-of-order (common with UDP) get rejected. Example: receive packet #100, then packet #99 arrives late → rejected even though legitimate
What three properties does the sliding window replay filter provide?|1. Accepts packets within reasonable window (8,128 packets) that haven't been seen<br>2. Rejects duplicate packets (replay attacks)<br>3. Handles out-of-order delivery (real networks)
After handshake completion, what happens to the ephemeral private keys?|They go out of scope and are garbage collected, becoming unrecoverable. This is critical for forward secrecy - even if static keys leak later, the ephemeral keys are gone forever
What is the security benefit of using the hash transcript as additional data in AEAD?|It binds each encryption to the exact state of the handshake at that moment. Any tampering with previous messages changes the hash, which causes AEAD decryption to fail. This prevents message substitution attacks
Why can't an eavesdropper determine the initiator's identity in a WireGuard handshake?|The initiator's static public key is encrypted using a key derived from \( \text{DH}(\text{initiator}_{\text{ephemeral}_{\text{private}}}, \text{responder}_{\text{static}_{\text{public}}}) \). The eavesdropper only sees public keys, not private keys, so cannot compute this DH shared secret
What would happen if WireGuard reused the same nonce for multiple transport packets with the same key?|Catastrophic security failure - reusing (key, nonce) pairs in ChaCha20-Poly1305 can leak the encryption key and allow attackers to decrypt messages or forge authenticated messages
Why does the handshake mix both public and secret data at each step?|<b>Public data</b> (ephemeral public keys, ciphertexts) goes into hash transcript for authentication and context binding. <b>Secret data</b> (DH results) goes into chaining key for key derivation. Together they ensure both authentication and confidentiality
What prevents an attacker from splicing together parts of different handshakes?|The hash transcript - it's a running hash of all messages that gets used as additional data in every AEAD encryption. If messages are from different handshakes, the hash won't match and AEAD decryption will fail
